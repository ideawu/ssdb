'\" t
.\"     Title: JEMALLOC
.\"    Author: Jason Evans
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 03/06/2013
.\"    Manual: User Manual
.\"    Source: jemalloc 3.3.1-0-g9ef9d9e8c271cdf14f664b871a8f98c827714784
.\"  Language: English
.\"
.TH "JEMALLOC" "3" "03/06/2013" "jemalloc 3.3.1-0-g9ef9d9e8c271" "User Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
jemalloc \- general purpose memory allocation functions
.SH "LIBRARY"
.PP
This manual describes jemalloc 3\&.3\&.1\-0\-g9ef9d9e8c271cdf14f664b871a8f98c827714784\&. More information can be found at the
\m[blue]\fBjemalloc website\fR\m[]\&\s-2\u[1]\d\s+2\&.
.SH "SYNOPSIS"
.sp
.ft B
.nf
#include <stdlib\&.h>
#include <jemalloc/jemalloc\&.h>
.fi
.ft
.SS "Standard API"
.HP \w'void\ *malloc('u
.BI "void *malloc(size_t\ " "size" ");"
.HP \w'void\ *calloc('u
.BI "void *calloc(size_t\ " "number" ", size_t\ " "size" ");"
.HP \w'int\ posix_memalign('u
.BI "int posix_memalign(void\ **" "ptr" ", size_t\ " "alignment" ", size_t\ " "size" ");"
.HP \w'void\ *aligned_alloc('u
.BI "void *aligned_alloc(size_t\ " "alignment" ", size_t\ " "size" ");"
.HP \w'void\ *realloc('u
.BI "void *realloc(void\ *" "ptr" ", size_t\ " "size" ");"
.HP \w'void\ free('u
.BI "void free(void\ *" "ptr" ");"
.SS "Non\-standard API"
.HP \w'size_t\ malloc_usable_size('u
.BI "size_t malloc_usable_size(const\ void\ *" "ptr" ");"
.HP \w'void\ malloc_stats_print('u
.BI "void malloc_stats_print(void\ " "(*write_cb)" "\ (void\ *,\ const\ char\ *), void\ *" "cbopaque" ", const\ char\ *" "opts" ");"
.HP \w'int\ mallctl('u
.BI "int mallctl(const\ char\ *" "name" ", void\ *" "oldp" ", size_t\ *" "oldlenp" ", void\ *" "newp" ", size_t\ " "newlen" ");"
.HP \w'int\ mallctlnametomib('u
.BI "int mallctlnametomib(const\ char\ *" "name" ", size_t\ *" "mibp" ", size_t\ *" "miblenp" ");"
.HP \w'int\ mallctlbymib('u
.BI "int mallctlbymib(const\ size_t\ *" "mib" ", size_t\ " "miblen" ", void\ *" "oldp" ", size_t\ *" "oldlenp" ", void\ *" "newp" ", size_t\ " "newlen" ");"
.HP \w'void\ (*malloc_message)('u
.BI "void (*malloc_message)(void\ *" "cbopaque" ", const\ char\ *" "s" ");"
.PP
const char *\fImalloc_conf\fR;
.SS "Experimental API"
.HP \w'int\ allocm('u
.BI "int allocm(void\ **" "ptr" ", size_t\ *" "rsize" ", size_t\ " "size" ", int\ " "flags" ");"
.HP \w'int\ rallocm('u
.BI "int rallocm(void\ **" "ptr" ", size_t\ *" "rsize" ", size_t\ " "size" ", size_t\ " "extra" ", int\ " "flags" ");"
.HP \w'int\ sallocm('u
.BI "int sallocm(const\ void\ *" "ptr" ", size_t\ *" "rsize" ", int\ " "flags" ");"
.HP \w'int\ dallocm('u
.BI "int dallocm(void\ *" "ptr" ", int\ " "flags" ");"
.HP \w'int\ nallocm('u
.BI "int nallocm(size_t\ *" "rsize" ", size_t\ " "size" ", int\ " "flags" ");"
.SH "DESCRIPTION"
.SS "Standard API"
.PP
The
\fBmalloc\fR\fB\fR
function allocates
\fIsize\fR
bytes of uninitialized memory\&. The allocated space is suitably aligned (after possible pointer coercion) for storage of any type of object\&.
.PP
The
\fBcalloc\fR\fB\fR
function allocates space for
\fInumber\fR
objects, each
\fIsize\fR
bytes in length\&. The result is identical to calling
\fBmalloc\fR\fB\fR
with an argument of
\fInumber\fR
*
\fIsize\fR, with the exception that the allocated memory is explicitly initialized to zero bytes\&.
.PP
The
\fBposix_memalign\fR\fB\fR
function allocates
\fIsize\fR
bytes of memory such that the allocation\*(Aqs base address is an even multiple of
\fIalignment\fR, and returns the allocation in the value pointed to by
\fIptr\fR\&. The requested
\fIalignment\fR
must be a power of 2 at least as large as
sizeof(\fBvoid *\fR)\&.
.PP
The
\fBaligned_alloc\fR\fB\fR
function allocates
\fIsize\fR
bytes of memory such that the allocation\*(Aqs base address is an even multiple of
\fIalignment\fR\&. The requested
\fIalignment\fR
must be a power of 2\&. Behavior is undefined if
\fIsize\fR
is not an integral multiple of
\fIalignment\fR\&.
.PP
The
\fBrealloc\fR\fB\fR
function changes the size of the previously allocated memory referenced by
\fIptr\fR
to
\fIsize\fR
bytes\&. The contents of the memory are unchanged up to the lesser of the new and old sizes\&. If the new size is larger, the contents of the newly allocated portion of the memory are undefined\&. Upon success, the memory referenced by
\fIptr\fR
is freed and a pointer to the newly allocated memory is returned\&. Note that
\fBrealloc\fR\fB\fR
may move the memory allocation, resulting in a different return value than
\fIptr\fR\&. If
\fIptr\fR
is
\fBNULL\fR, the
\fBrealloc\fR\fB\fR
function behaves identically to
\fBmalloc\fR\fB\fR
for the specified size\&.
.PP
The
\fBfree\fR\fB\fR
function causes the allocated memory referenced by
\fIptr\fR
to be made available for future allocations\&. If
\fIptr\fR
is
\fBNULL\fR, no action occurs\&.
.SS "Non\-standard API"
.PP
The
\fBmalloc_usable_size\fR\fB\fR
function returns the usable size of the allocation pointed to by
\fIptr\fR\&. The return value may be larger than the size that was requested during allocation\&. The
\fBmalloc_usable_size\fR\fB\fR
function is not a mechanism for in\-place
\fBrealloc\fR\fB\fR; rather it is provided solely as a tool for introspection purposes\&. Any discrepancy between the requested allocation size and the size reported by
\fBmalloc_usable_size\fR\fB\fR
should not be depended on, since such behavior is entirely implementation\-dependent\&.
.PP
The
\fBmalloc_stats_print\fR\fB\fR
function writes human\-readable summary statistics via the
\fIwrite_cb\fR
callback function pointer and
\fIcbopaque\fR
data passed to
\fIwrite_cb\fR, or
\fBmalloc_message\fR\fB\fR
if
\fIwrite_cb\fR
is
\fBNULL\fR\&. This function can be called repeatedly\&. General information that never changes during execution can be omitted by specifying "g" as a character within the
\fIopts\fR
string\&. Note that
\fBmalloc_message\fR\fB\fR
uses the
\fBmallctl*\fR\fB\fR
functions internally, so inconsistent statistics can be reported if multiple threads use these functions simultaneously\&. If
\fB\-\-enable\-stats\fR
is specified during configuration, \(lqm\(rq and \(lqa\(rq can be specified to omit merged arena and per arena statistics, respectively; \(lqb\(rq and \(lql\(rq can be specified to omit per size class statistics for bins and large objects, respectively\&. Unrecognized characters are silently ignored\&. Note that thread caching may prevent some statistics from being completely up to date, since extra locking would be required to merge counters that track thread cache operations\&.
.PP
The
\fBmallctl\fR\fB\fR
function provides a general interface for introspecting the memory allocator, as well as setting modifiable parameters and triggering actions\&. The period\-separated
\fIname\fR
argument specifies a location in a tree\-structured namespace; see the
MALLCTL NAMESPACE
section for documentation on the tree contents\&. To read a value, pass a pointer via
\fIoldp\fR
to adequate space to contain the value, and a pointer to its length via
\fIoldlenp\fR; otherwise pass
\fBNULL\fR
and
\fBNULL\fR\&. Similarly, to write a value, pass a pointer to the value via
\fInewp\fR, and its length via
\fInewlen\fR; otherwise pass
\fBNULL\fR
and
\fB0\fR\&.
.PP
The
\fBmallctlnametomib\fR\fB\fR
function provides a way to avoid repeated name lookups for applications that repeatedly query the same portion of the namespace, by translating a name to a \(lqManagement Information Base\(rq (MIB) that can be passed repeatedly to
\fBmallctlbymib\fR\fB\fR\&. Upon successful return from
\fBmallctlnametomib\fR\fB\fR,
\fImibp\fR
contains an array of
\fI*miblenp\fR
integers, where
\fI*miblenp\fR
is the lesser of the number of components in
\fIname\fR
and the input value of
\fI*miblenp\fR\&. Thus it is possible to pass a
\fI*miblenp\fR
that is smaller than the number of period\-separated name components, which results in a partial MIB that can be used as the basis for constructing a complete MIB\&. For name components that are integers (e\&.g\&. the 2 in
"arenas\&.bin\&.2\&.size"), the corresponding MIB component will always be that integer\&. Therefore, it is legitimate to construct code like the following:
.sp
.if n \{\
.RS 4
.\}
.nf
unsigned nbins, i;

int mib[4];
size_t len, miblen;

len = sizeof(nbins);
mallctl("arenas\&.nbins", &nbins, &len, NULL, 0);

miblen = 4;
mallnametomib("arenas\&.bin\&.0\&.size", mib, &miblen);
for (i = 0; i < nbins; i++) {
	size_t bin_size;

	mib[2] = i;
	len = sizeof(bin_size);
	mallctlbymib(mib, miblen, &bin_size, &len, NULL, 0);
	/* Do something with bin_size\&.\&.\&. */
}
.fi
.if n \{\
.RE
.\}
.SS "Experimental API"
.PP
The experimental API is subject to change or removal without regard for backward compatibility\&. If
\fB\-\-disable\-experimental\fR
is specified during configuration, the experimental API is omitted\&.
.PP
The
\fBallocm\fR\fB\fR,
\fBrallocm\fR\fB\fR,
\fBsallocm\fR\fB\fR,
\fBdallocm\fR\fB\fR, and
\fBnallocm\fR\fB\fR
functions all have a
\fIflags\fR
argument that can be used to specify options\&. The functions only check the options that are contextually relevant\&. Use bitwise or (|) operations to specify one or more of the following:
.PP
\fBALLOCM_LG_ALIGN(\fR\fB\fIla\fR\fR\fB) \fR
.RS 4
Align the memory allocation to start at an address that is a multiple of
(1 << \fIla\fR)\&. This macro does not validate that
\fIla\fR
is within the valid range\&.
.RE
.PP
\fBALLOCM_ALIGN(\fR\fB\fIa\fR\fR\fB) \fR
.RS 4
Align the memory allocation to start at an address that is a multiple of
\fIa\fR, where
\fIa\fR
is a power of two\&. This macro does not validate that
\fIa\fR
is a power of 2\&.
.RE
.PP
\fBALLOCM_ZERO\fR
.RS 4
Initialize newly allocated memory to contain zero bytes\&. In the growing reallocation case, the real size prior to reallocation defines the boundary between untouched bytes and those that are initialized to contain zero bytes\&. If this option is absent, newly allocated memory is uninitialized\&.
.RE
.PP
\fBALLOCM_NO_MOVE\fR
.RS 4
For reallocation, fail rather than moving the object\&. This constraint can apply to both growth and shrinkage\&.
.RE
.PP
\fBALLOCM_ARENA(\fR\fB\fIa\fR\fR\fB) \fR
.RS 4
Use the arena specified by the index
\fIa\fR\&. This macro does not validate that
\fIa\fR
specifies an arena in the valid range\&.
.RE
.PP
The
\fBallocm\fR\fB\fR
function allocates at least
\fIsize\fR
bytes of memory, sets
\fI*ptr\fR
to the base address of the allocation, and sets
\fI*rsize\fR
to the real size of the allocation if
\fIrsize\fR
is not
\fBNULL\fR\&. Behavior is undefined if
\fIsize\fR
is
\fB0\fR\&.
.PP
The
\fBrallocm\fR\fB\fR
function resizes the allocation at
\fI*ptr\fR
to be at least
\fIsize\fR
bytes, sets
\fI*ptr\fR
to the base address of the allocation if it moved, and sets
\fI*rsize\fR
to the real size of the allocation if
\fIrsize\fR
is not
\fBNULL\fR\&. If
\fIextra\fR
is non\-zero, an attempt is made to resize the allocation to be at least
\fIsize\fR + \fIextra\fR)
bytes, though inability to allocate the extra byte(s) will not by itself result in failure\&. Behavior is undefined if
\fIsize\fR
is
\fB0\fR, or if
(\fIsize\fR + \fIextra\fR > \fBSIZE_T_MAX\fR)\&.
.PP
The
\fBsallocm\fR\fB\fR
function sets
\fI*rsize\fR
to the real size of the allocation\&.
.PP
The
\fBdallocm\fR\fB\fR
function causes the memory referenced by
\fIptr\fR
to be made available for future allocations\&.
.PP
The
\fBnallocm\fR\fB\fR
function allocates no memory, but it performs the same size computation as the
\fBallocm\fR\fB\fR
function, and if
\fIrsize\fR
is not
\fBNULL\fR
it sets
\fI*rsize\fR
to the real size of the allocation that would result from the equivalent
\fBallocm\fR\fB\fR
function call\&. Behavior is undefined if
\fIsize\fR
is
\fB0\fR\&.
.SH "TUNING"
.PP
Once, when the first call is made to one of the memory allocation routines, the allocator initializes its internals based in part on various options that can be specified at compile\- or run\-time\&.
.PP
The string pointed to by the global variable
\fImalloc_conf\fR, the \(lqname\(rq of the file referenced by the symbolic link named
/etc/malloc\&.conf, and the value of the environment variable
\fBMALLOC_CONF\fR, will be interpreted, in that order, from left to right as options\&.
.PP
An options string is a comma\-separated list of option:value pairs\&. There is one key corresponding to each
"opt\&.*"
mallctl (see the
MALLCTL NAMESPACE
section for options documentation)\&. For example,
abort:true,narenas:1
sets the
"opt\&.abort"
and
"opt\&.narenas"
options\&. Some options have boolean values (true/false), others have integer values (base 8, 10, or 16, depending on prefix), and yet others have raw string values\&.
.SH "IMPLEMENTATION NOTES"
.PP
Traditionally, allocators have used
\fBsbrk\fR(2)
to obtain memory, which is suboptimal for several reasons, including race conditions, increased fragmentation, and artificial limitations on maximum usable memory\&. If
\fB\-\-enable\-dss\fR
is specified during configuration, this allocator uses both
\fBmmap\fR(2)
and
\fBsbrk\fR(2), in that order of preference; otherwise only
\fBmmap\fR(2)
is used\&.
.PP
This allocator uses multiple arenas in order to reduce lock contention for threaded programs on multi\-processor systems\&. This works well with regard to threading scalability, but incurs some costs\&. There is a small fixed per\-arena overhead, and additionally, arenas manage memory completely independently of each other, which means a small fixed increase in overall memory fragmentation\&. These overheads are not generally an issue, given the number of arenas normally used\&. Note that using substantially more arenas than the default is not likely to improve performance, mainly due to reduced cache performance\&. However, it may make sense to reduce the number of arenas if an application does not make much use of the allocation functions\&.
.PP
In addition to multiple arenas, unless
\fB\-\-disable\-tcache\fR
is specified during configuration, this allocator supports thread\-specific caching for small and large objects, in order to make it possible to completely avoid synchronization for most allocation requests\&. Such caching allows very fast allocation in the common case, but it increases memory usage and fragmentation, since a bounded number of objects can remain allocated in each thread cache\&.
.PP
Memory is conceptually broken into equal\-sized chunks, where the chunk size is a power of two that is greater than the page size\&. Chunks are always aligned to multiples of the chunk size\&. This alignment makes it possible to find metadata for user objects very quickly\&.
.PP
User objects are broken into three categories according to size: small, large, and huge\&. Small objects are smaller than one page\&. Large objects are smaller than the chunk size\&. Huge objects are a multiple of the chunk size\&. Small and large objects are managed by arenas; huge objects are managed separately in a single data structure that is shared by all threads\&. Huge objects are used by applications infrequently enough that this single data structure is not a scalability issue\&.
.PP
Each chunk that is managed by an arena tracks its contents as runs of contiguous pages (unused, backing a set of small objects, or backing one large object)\&. The combination of chunk alignment and chunk page maps makes it possible to determine all metadata regarding small and large allocations in constant time\&.
.PP
Small objects are managed in groups by page runs\&. Each run maintains a frontier and free list to track which regions are in use\&. Allocation requests that are no more than half the quantum (8 or 16, depending on architecture) are rounded up to the nearest power of two that is at least
sizeof(\fBdouble\fR)\&. All other small object size classes are multiples of the quantum, spaced such that internal fragmentation is limited to approximately 25% for all but the smallest size classes\&. Allocation requests that are larger than the maximum small size class, but small enough to fit in an arena\-managed chunk (see the
"opt\&.lg_chunk"
option), are rounded up to the nearest run size\&. Allocation requests that are too large to fit in an arena\-managed chunk are rounded up to the nearest multiple of the chunk size\&.
.PP
Allocations are packed tightly together, which can be an issue for multi\-threaded applications\&. If you need to assure that allocations do not suffer from cacheline sharing, round your allocation requests up to the nearest multiple of the cacheline size, or specify cacheline alignment when allocating\&.
.PP
Assuming 4 MiB chunks, 4 KiB pages, and a 16\-byte quantum on a 64\-bit system, the size classes in each category are as shown in
Table 1\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&1.\ \&Size classes
.TS
allbox tab(:);
lB rB lB.
T{
Category
T}:T{
Spacing
T}:T{
Size
T}
.T&
l r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
l r l
l r l.
T{
Small
T}:T{
lg
T}:T{
[8]
T}
:T{
16
T}:T{
[16, 32, 48, \&.\&.\&., 128]
T}
:T{
32
T}:T{
[160, 192, 224, 256]
T}
:T{
64
T}:T{
[320, 384, 448, 512]
T}
:T{
128
T}:T{
[640, 768, 896, 1024]
T}
:T{
256
T}:T{
[1280, 1536, 1792, 2048]
T}
:T{
512
T}:T{
[2560, 3072, 3584]
T}
T{
Large
T}:T{
4 KiB
T}:T{
[4 KiB, 8 KiB, 12 KiB, \&.\&.\&., 4072 KiB]
T}
T{
Huge
T}:T{
4 MiB
T}:T{
[4 MiB, 8 MiB, 12 MiB, \&.\&.\&.]
T}
.TE
.sp 1
.SH "MALLCTL NAMESPACE"
.PP
The following names are defined in the namespace accessible via the
\fBmallctl*\fR\fB\fR
functions\&. Value types are specified in parentheses, their readable/writable statuses are encoded as
rw,
r\-,
\-w, or
\-\-, and required build configuration flags follow, if any\&. A name element encoded as
<i>
or
<j>
indicates an integer component, where the integer varies from 0 to some upper value that must be determined via introspection\&. In the case of
"stats\&.arenas\&.<i>\&.*",
<i>
equal to
"arenas\&.narenas"
can be used to access the summation of statistics from all arenas\&. Take special note of the
"epoch"
mallctl, which controls refreshing of cached dynamic statistics\&.
.PP
"version" (\fBconst char *\fR) r\-
.RS 4
Return the jemalloc version string\&.
.RE
.PP
"epoch" (\fBuint64_t\fR) rw
.RS 4
If a value is passed in, refresh the data from which the
\fBmallctl*\fR\fB\fR
functions report values, and increment the epoch\&. Return the current epoch\&. This is useful for detecting whether another thread caused a refresh\&.
.RE
.PP
"config\&.debug" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-debug\fR
was specified during build configuration\&.
.RE
.PP
"config\&.dss" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-dss\fR
was specified during build configuration\&.
.RE
.PP
"config\&.fill" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-fill\fR
was specified during build configuration\&.
.RE
.PP
"config\&.lazy_lock" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-lazy\-lock\fR
was specified during build configuration\&.
.RE
.PP
"config\&.mremap" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-mremap\fR
was specified during build configuration\&.
.RE
.PP
"config\&.munmap" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-munmap\fR
was specified during build configuration\&.
.RE
.PP
"config\&.prof" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-prof\fR
was specified during build configuration\&.
.RE
.PP
"config\&.prof_libgcc" (\fBbool\fR) r\-
.RS 4
\fB\-\-disable\-prof\-libgcc\fR
was not specified during build configuration\&.
.RE
.PP
"config\&.prof_libunwind" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-prof\-libunwind\fR
was specified during build configuration\&.
.RE
.PP
"config\&.stats" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-stats\fR
was specified during build configuration\&.
.RE
.PP
"config\&.tcache" (\fBbool\fR) r\-
.RS 4
\fB\-\-disable\-tcache\fR
was not specified during build configuration\&.
.RE
.PP
"config\&.tls" (\fBbool\fR) r\-
.RS 4
\fB\-\-disable\-tls\fR
was not specified during build configuration\&.
.RE
.PP
"config\&.utrace" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-utrace\fR
was specified during build configuration\&.
.RE
.PP
"config\&.valgrind" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-valgrind\fR
was specified during build configuration\&.
.RE
.PP
"config\&.xmalloc" (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-xmalloc\fR
was specified during build configuration\&.
.RE
.PP
"opt\&.abort" (\fBbool\fR) r\-
.RS 4
Abort\-on\-warning enabled/disabled\&. If true, most warnings are fatal\&. The process will call
\fBabort\fR(3)
in these cases\&. This option is disabled by default unless
\fB\-\-enable\-debug\fR
is specified during configuration, in which case it is enabled by default\&.
.RE
.PP
"opt\&.lg_chunk" (\fBsize_t\fR) r\-
.RS 4
Virtual memory chunk size (log base 2)\&. If a chunk size outside the supported size range is specified, the size is silently clipped to the minimum/maximum supported size\&. The default chunk size is 4 MiB (2^22)\&.
.RE
.PP
"opt\&.dss" (\fBconst char *\fR) r\-
.RS 4
dss (\fBsbrk\fR(2)) allocation precedence as related to
\fBmmap\fR(2)
allocation\&. The following settings are supported: \(lqdisabled\(rq, \(lqprimary\(rq, and \(lqsecondary\(rq (default)\&.
.RE
.PP
"opt\&.narenas" (\fBsize_t\fR) r\-
.RS 4
Maximum number of arenas to use for automatic multiplexing of threads and arenas\&. The default is four times the number of CPUs, or one if there is a single CPU\&.
.RE
.PP
"opt\&.lg_dirty_mult" (\fBssize_t\fR) r\-
.RS 4
Per\-arena minimum ratio (log base 2) of active to dirty pages\&. Some dirty unused pages may be allowed to accumulate, within the limit set by the ratio (or one chunk worth of dirty pages, whichever is greater), before informing the kernel about some of those pages via
\fBmadvise\fR(2)
or a similar system call\&. This provides the kernel with sufficient information to recycle dirty pages if physical memory becomes scarce and the pages remain unused\&. The default minimum ratio is 8:1 (2^3:1); an option value of \-1 will disable dirty page purging\&.
.RE
.PP
"opt\&.stats_print" (\fBbool\fR) r\-
.RS 4
Enable/disable statistics printing at exit\&. If enabled, the
\fBmalloc_stats_print\fR\fB\fR
function is called at program exit via an
\fBatexit\fR(3)
function\&. If
\fB\-\-enable\-stats\fR
is specified during configuration, this has the potential to cause deadlock for a multi\-threaded process that exits while one or more threads are executing in the memory allocation functions\&. Therefore, this option should only be used with care; it is primarily intended as a performance tuning aid during application development\&. This option is disabled by default\&.
.RE
.PP
"opt\&.junk" (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
.RS 4
Junk filling enabled/disabled\&. If enabled, each byte of uninitialized allocated memory will be initialized to
0xa5\&. All deallocated memory will be initialized to
0x5a\&. This is intended for debugging and will impact performance negatively\&. This option is disabled by default unless
\fB\-\-enable\-debug\fR
is specified during configuration, in which case it is enabled by default unless running inside
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2\&.
.RE
.PP
"opt\&.quarantine" (\fBsize_t\fR) r\- [\fB\-\-enable\-fill\fR]
.RS 4
Per thread quarantine size in bytes\&. If non\-zero, each thread maintains a FIFO object quarantine that stores up to the specified number of bytes of memory\&. The quarantined memory is not freed until it is released from quarantine, though it is immediately junk\-filled if the
"opt\&.junk"
option is enabled\&. This feature is of particular use in combination with
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2, which can detect attempts to access quarantined objects\&. This is intended for debugging and will impact performance negatively\&. The default quarantine size is 0 unless running inside Valgrind, in which case the default is 16 MiB\&.
.RE
.PP
"opt\&.redzone" (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
.RS 4
Redzones enabled/disabled\&. If enabled, small allocations have redzones before and after them\&. Furthermore, if the
"opt\&.junk"
option is enabled, the redzones are checked for corruption during deallocation\&. However, the primary intended purpose of this feature is to be used in combination with
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2, which needs redzones in order to do effective buffer overflow/underflow detection\&. This option is intended for debugging and will impact performance negatively\&. This option is disabled by default unless running inside Valgrind\&.
.RE
.PP
"opt\&.zero" (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
.RS 4
Zero filling enabled/disabled\&. If enabled, each byte of uninitialized allocated memory will be initialized to 0\&. Note that this initialization only happens once for each byte, so
\fBrealloc\fR\fB\fR
and
\fBrallocm\fR\fB\fR
calls do not zero memory that was previously allocated\&. This is intended for debugging and will impact performance negatively\&. This option is disabled by default\&.
.RE
.PP
"opt\&.utrace" (\fBbool\fR) r\- [\fB\-\-enable\-utrace\fR]
.RS 4
Allocation tracing based on
\fButrace\fR(2)
enabled/disabled\&. This option is disabled by default\&.
.RE
.PP
"opt\&.valgrind" (\fBbool\fR) r\- [\fB\-\-enable\-valgrind\fR]
.RS 4
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2
support enabled/disabled\&. This option is vestigal because jemalloc auto\-detects whether it is running inside Valgrind\&. This option is disabled by default, unless running inside Valgrind\&.
.RE
.PP
"opt\&.xmalloc" (\fBbool\fR) r\- [\fB\-\-enable\-xmalloc\fR]
.RS 4
Abort\-on\-out\-of\-memory enabled/disabled\&. If enabled, rather than returning failure for any allocation function, display a diagnostic message on
\fBSTDERR_FILENO\fR
and cause the program to drop core (using
\fBabort\fR(3))\&. If an application is designed to depend on this behavior, set the option at compile time by including the following in the source code:
.sp
.if n \{\
.RS 4
.\}
.nf
malloc_conf = "xmalloc:true";
.fi
.if n \{\
.RE
.\}
.sp
This option is disabled by default\&.
.RE
.PP
"opt\&.tcache" (\fBbool\fR) r\- [\fB\-\-enable\-tcache\fR]
.RS 4
Thread\-specific caching enabled/disabled\&. When there are multiple threads, each thread uses a thread\-specific cache for objects up to a certain size\&. Thread\-specific caching allows many allocations to be satisfied without performing any thread synchronization, at the cost of increased memory use\&. See the
"opt\&.lg_tcache_max"
option for related tuning information\&. This option is enabled by default unless running inside
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2\&.
.RE
.PP
"opt\&.lg_tcache_max" (\fBsize_t\fR) r\- [\fB\-\-enable\-tcache\fR]
.RS 4
Maximum size class (log base 2) to cache in the thread\-specific cache\&. At a minimum, all small size classes are cached, and at a maximum all large size classes are cached\&. The default maximum is 32 KiB (2^15)\&.
.RE
.PP
"opt\&.prof" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Memory profiling enabled/disabled\&. If enabled, profile memory allocation activity\&. See the
"opt\&.prof_active"
option for on\-the\-fly activation/deactivation\&. See the
"opt\&.lg_prof_sample"
option for probabilistic sampling control\&. See the
"opt\&.prof_accum"
option for control of cumulative sample reporting\&. See the
"opt\&.lg_prof_interval"
option for information on interval\-triggered profile dumping, the
"opt\&.prof_gdump"
option for information on high\-water\-triggered profile dumping, and the
"opt\&.prof_final"
option for final profile dumping\&. Profile output is compatible with the included
\fBpprof\fR
Perl script, which originates from the
\m[blue]\fBgperftools package\fR\m[]\&\s-2\u[3]\d\s+2\&.
.RE
.PP
"opt\&.prof_prefix" (\fBconst char *\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Filename prefix for profile dumps\&. If the prefix is set to the empty string, no automatic dumps will occur; this is primarily useful for disabling the automatic final heap dump (which also disables leak reporting, if enabled)\&. The default prefix is
jeprof\&.
.RE
.PP
"opt\&.prof_active" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Profiling activated/deactivated\&. This is a secondary control mechanism that makes it possible to start the application with profiling enabled (see the
"opt\&.prof"
option) but inactive, then toggle profiling at any time during program execution with the
"prof\&.active"
mallctl\&. This option is enabled by default\&.
.RE
.PP
"opt\&.lg_prof_sample" (\fBssize_t\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Average interval (log base 2) between allocation samples, as measured in bytes of allocation activity\&. Increasing the sampling interval decreases profile fidelity, but also decreases the computational overhead\&. The default sample interval is 512 KiB (2^19 B)\&.
.RE
.PP
"opt\&.prof_accum" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Reporting of cumulative object/byte counts in profile dumps enabled/disabled\&. If this option is enabled, every unique backtrace must be stored for the duration of execution\&. Depending on the application, this can impose a large memory overhead, and the cumulative counts are not always of interest\&. This option is disabled by default\&.
.RE
.PP
"opt\&.lg_prof_interval" (\fBssize_t\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Average interval (log base 2) between memory profile dumps, as measured in bytes of allocation activity\&. The actual interval between dumps may be sporadic because decentralized allocation counters are used to avoid synchronization bottlenecks\&. Profiles are dumped to files named according to the pattern
<prefix>\&.<pid>\&.<seq>\&.i<iseq>\&.heap, where
<prefix>
is controlled by the
"opt\&.prof_prefix"
option\&. By default, interval\-triggered profile dumping is disabled (encoded as \-1)\&.
.RE
.PP
"opt\&.prof_gdump" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Trigger a memory profile dump every time the total virtual memory exceeds the previous maximum\&. Profiles are dumped to files named according to the pattern
<prefix>\&.<pid>\&.<seq>\&.u<useq>\&.heap, where
<prefix>
is controlled by the
"opt\&.prof_prefix"
option\&. This option is disabled by default\&.
.RE
.PP
"opt\&.prof_final" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Use an
\fBatexit\fR(3)
function to dump final memory usage to a file named according to the pattern
<prefix>\&.<pid>\&.<seq>\&.f\&.heap, where
<prefix>
is controlled by the
"opt\&.prof_prefix"
option\&. This option is enabled by default\&.
.RE
.PP
"opt\&.prof_leak" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Leak reporting enabled/disabled\&. If enabled, use an
\fBatexit\fR(3)
function to report memory leaks detected by allocation sampling\&. See the
"opt\&.prof"
option for information on analyzing heap profile output\&. This option is disabled by default\&.
.RE
.PP
"thread\&.arena" (\fBunsigned\fR) rw
.RS 4
Get or set the arena associated with the calling thread\&. If the specified arena was not initialized beforehand (see the
"arenas\&.initialized"
mallctl), it will be automatically initialized as a side effect of calling this interface\&.
.RE
.PP
"thread\&.allocated" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Get the total number of bytes ever allocated by the calling thread\&. This counter has the potential to wrap around; it is up to the application to appropriately interpret the counter in such cases\&.
.RE
.PP
"thread\&.allocatedp" (\fBuint64_t *\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Get a pointer to the the value that is returned by the
"thread\&.allocated"
mallctl\&. This is useful for avoiding the overhead of repeated
\fBmallctl*\fR\fB\fR
calls\&.
.RE
.PP
"thread\&.deallocated" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Get the total number of bytes ever deallocated by the calling thread\&. This counter has the potential to wrap around; it is up to the application to appropriately interpret the counter in such cases\&.
.RE
.PP
"thread\&.deallocatedp" (\fBuint64_t *\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Get a pointer to the the value that is returned by the
"thread\&.deallocated"
mallctl\&. This is useful for avoiding the overhead of repeated
\fBmallctl*\fR\fB\fR
calls\&.
.RE
.PP
"thread\&.tcache\&.enabled" (\fBbool\fR) rw [\fB\-\-enable\-tcache\fR]
.RS 4
Enable/disable calling thread\*(Aqs tcache\&. The tcache is implicitly flushed as a side effect of becoming disabled (see
"thread\&.tcache\&.flush")\&.
.RE
.PP
"thread\&.tcache\&.flush" (\fBvoid\fR) \-\- [\fB\-\-enable\-tcache\fR]
.RS 4
Flush calling thread\*(Aqs tcache\&. This interface releases all cached objects and internal data structures associated with the calling thread\*(Aqs thread\-specific cache\&. Ordinarily, this interface need not be called, since automatic periodic incremental garbage collection occurs, and the thread cache is automatically discarded when a thread exits\&. However, garbage collection is triggered by allocation activity, so it is possible for a thread that stops allocating/deallocating to retain its cache indefinitely, in which case the developer may find manual flushing useful\&.
.RE
.PP
"arena\&.<i>\&.purge" (\fBunsigned\fR) \-\-
.RS 4
Purge unused dirty pages for arena <i>, or for all arenas if <i> equals
"arenas\&.narenas"\&.
.RE
.PP
"arena\&.<i>\&.dss" (\fBconst char *\fR) rw
.RS 4
Set the precedence of dss allocation as related to mmap allocation for arena <i>, or for all arenas if <i> equals
"arenas\&.narenas"\&. See
"opt\&.dss"
for supported settings\&.
.RE
.PP
"arenas\&.narenas" (\fBunsigned\fR) r\-
.RS 4
Current limit on number of arenas\&.
.RE
.PP
"arenas\&.initialized" (\fBbool *\fR) r\-
.RS 4
An array of
"arenas\&.narenas"
booleans\&. Each boolean indicates whether the corresponding arena is initialized\&.
.RE
.PP
"arenas\&.quantum" (\fBsize_t\fR) r\-
.RS 4
Quantum size\&.
.RE
.PP
"arenas\&.page" (\fBsize_t\fR) r\-
.RS 4
Page size\&.
.RE
.PP
"arenas\&.tcache_max" (\fBsize_t\fR) r\- [\fB\-\-enable\-tcache\fR]
.RS 4
Maximum thread\-cached size class\&.
.RE
.PP
"arenas\&.nbins" (\fBunsigned\fR) r\-
.RS 4
Number of bin size classes\&.
.RE
.PP
"arenas\&.nhbins" (\fBunsigned\fR) r\- [\fB\-\-enable\-tcache\fR]
.RS 4
Total number of thread cache bin size classes\&.
.RE
.PP
"arenas\&.bin\&.<i>\&.size" (\fBsize_t\fR) r\-
.RS 4
Maximum size supported by size class\&.
.RE
.PP
"arenas\&.bin\&.<i>\&.nregs" (\fBuint32_t\fR) r\-
.RS 4
Number of regions per page run\&.
.RE
.PP
"arenas\&.bin\&.<i>\&.run_size" (\fBsize_t\fR) r\-
.RS 4
Number of bytes per page run\&.
.RE
.PP
"arenas\&.nlruns" (\fBsize_t\fR) r\-
.RS 4
Total number of large size classes\&.
.RE
.PP
"arenas\&.lrun\&.<i>\&.size" (\fBsize_t\fR) r\-
.RS 4
Maximum size supported by this large size class\&.
.RE
.PP
"arenas\&.purge" (\fBunsigned\fR) \-w
.RS 4
Purge unused dirty pages for the specified arena, or for all arenas if none is specified\&.
.RE
.PP
"arenas\&.extend" (\fBunsigned\fR) r\-
.RS 4
Extend the array of arenas by appending a new arena, and returning the new arena index\&.
.RE
.PP
"prof\&.active" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
.RS 4
Control whether sampling is currently active\&. See the
"opt\&.prof_active"
option for additional information\&.
.RE
.PP
"prof\&.dump" (\fBconst char *\fR) \-w [\fB\-\-enable\-prof\fR]
.RS 4
Dump a memory profile to the specified file, or if NULL is specified, to a file according to the pattern
<prefix>\&.<pid>\&.<seq>\&.m<mseq>\&.heap, where
<prefix>
is controlled by the
"opt\&.prof_prefix"
option\&.
.RE
.PP
"prof\&.interval" (\fBuint64_t\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Average number of bytes allocated between inverval\-based profile dumps\&. See the
"opt\&.lg_prof_interval"
option for additional information\&.
.RE
.PP
"stats\&.cactive" (\fBsize_t *\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Pointer to a counter that contains an approximate count of the current number of bytes in active pages\&. The estimate may be high, but never low, because each arena rounds up to the nearest multiple of the chunk size when computing its contribution to the counter\&. Note that the
"epoch"
mallctl has no bearing on this counter\&. Furthermore, counter consistency is maintained via atomic operations, so it is necessary to use an atomic operation in order to guarantee a consistent read when dereferencing the pointer\&.
.RE
.PP
"stats\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Total number of bytes allocated by the application\&.
.RE
.PP
"stats\&.active" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Total number of bytes in active pages allocated by the application\&. This is a multiple of the page size, and greater than or equal to
"stats\&.allocated"\&. This does not include
"stats\&.arenas\&.<i>\&.pdirty"
and pages entirely devoted to allocator metadata\&.
.RE
.PP
"stats\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Total number of bytes in chunks mapped on behalf of the application\&. This is a multiple of the chunk size, and is at least as large as
"stats\&.active"\&. This does not include inactive chunks\&.
.RE
.PP
"stats\&.chunks\&.current" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Total number of chunks actively mapped on behalf of the application\&. This does not include inactive chunks\&.
.RE
.PP
"stats\&.chunks\&.total" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of chunks allocated\&.
.RE
.PP
"stats\&.chunks\&.high" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Maximum number of active chunks at any time thus far\&.
.RE
.PP
"stats\&.huge\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of bytes currently allocated by huge objects\&.
.RE
.PP
"stats\&.huge\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of huge allocation requests\&.
.RE
.PP
"stats\&.huge\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of huge deallocation requests\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.dss" (\fBconst char *\fR) r\-
.RS 4
dss (\fBsbrk\fR(2)) allocation precedence as related to
\fBmmap\fR(2)
allocation\&. See
"opt\&.dss"
for details\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.nthreads" (\fBunsigned\fR) r\-
.RS 4
Number of threads currently assigned to arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.pactive" (\fBsize_t\fR) r\-
.RS 4
Number of pages in active runs\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.pdirty" (\fBsize_t\fR) r\-
.RS 4
Number of pages within unused runs that are potentially dirty, and for which
\fBmadvise\fR\fB\fI\&.\&.\&.\fR\fR\fB \fR\fB\fI\fBMADV_DONTNEED\fR\fR\fR
or similar has not been called\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of mapped bytes\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.npurge" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of dirty page purge sweeps performed\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.nmadvise" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of
\fBmadvise\fR\fB\fI\&.\&.\&.\fR\fR\fB \fR\fB\fI\fBMADV_DONTNEED\fR\fR\fR
or similar calls made to purge dirty pages\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.npurged" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of pages purged\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.small\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of bytes currently allocated by small objects\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.small\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocation requests served by small bins\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.small\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of small objects returned to bins\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.small\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of small allocation requests\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.large\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Number of bytes currently allocated by large objects\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.large\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of large allocation requests served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.large\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of large deallocation requests served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.large\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of large allocation requests\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Current number of bytes allocated by bin\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocations served by bin\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocations returned to bin\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocation requests\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nfills" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR \fB\-\-enable\-tcache\fR]
.RS 4
Cumulative number of tcache fills\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nflushes" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR \fB\-\-enable\-tcache\fR]
.RS 4
Cumulative number of tcache flushes\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nruns" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of runs created\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nreruns" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of times the current run from which to allocate changed\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.bins\&.<j>\&.curruns" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Current number of runs\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocation requests for this size class served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of deallocation requests for this size class served directly by the arena\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Cumulative number of allocation requests for this size class\&.
.RE
.PP
"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.curruns" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Current number of runs for this size class\&.
.RE
.SH "DEBUGGING MALLOC PROBLEMS"
.PP
When debugging, it is a good idea to configure/build jemalloc with the
\fB\-\-enable\-debug\fR
and
\fB\-\-enable\-fill\fR
options, and recompile the program with suitable options and symbols for debugger support\&. When so configured, jemalloc incorporates a wide variety of run\-time assertions that catch application errors such as double\-free, write\-after\-free, etc\&.
.PP
Programs often accidentally depend on \(lquninitialized\(rq memory actually being filled with zero bytes\&. Junk filling (see the
"opt\&.junk"
option) tends to expose such bugs in the form of obviously incorrect results and/or coredumps\&. Conversely, zero filling (see the
"opt\&.zero"
option) eliminates the symptoms of such bugs\&. Between these two options, it is usually possible to quickly detect, diagnose, and eliminate such bugs\&.
.PP
This implementation does not provide much detail about the problems it detects, because the performance impact for storing such information would be prohibitive\&. However, jemalloc does integrate with the most excellent
\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2
tool if the
\fB\-\-enable\-valgrind\fR
configuration option is enabled\&.
.SH "DIAGNOSTIC MESSAGES"
.PP
If any of the memory allocation/deallocation functions detect an error or warning condition, a message will be printed to file descriptor
\fBSTDERR_FILENO\fR\&. Errors will result in the process dumping core\&. If the
"opt\&.abort"
option is set, most warnings are treated as errors\&.
.PP
The
\fImalloc_message\fR
variable allows the programmer to override the function which emits the text strings forming the errors and warnings if for some reason the
\fBSTDERR_FILENO\fR
file descriptor is not suitable for this\&.
\fBmalloc_message\fR\fB\fR
takes the
\fIcbopaque\fR
pointer argument that is
\fBNULL\fR
unless overridden by the arguments in a call to
\fBmalloc_stats_print\fR\fB\fR, followed by a string pointer\&. Please note that doing anything which tries to allocate memory in this function is likely to result in a crash or deadlock\&.
.PP
All messages are prefixed by \(lq<jemalloc>:\(rq\&.
.SH "RETURN VALUES"
.SS "Standard API"
.PP
The
\fBmalloc\fR\fB\fR
and
\fBcalloc\fR\fB\fR
functions return a pointer to the allocated memory if successful; otherwise a
\fBNULL\fR
pointer is returned and
\fIerrno\fR
is set to
ENOMEM\&.
.PP
The
\fBposix_memalign\fR\fB\fR
function returns the value 0 if successful; otherwise it returns an error value\&. The
\fBposix_memalign\fR\fB\fR
function will fail if:
.PP
EINVAL
.RS 4
The
\fIalignment\fR
parameter is not a power of 2 at least as large as
sizeof(\fBvoid *\fR)\&.
.RE
.PP
ENOMEM
.RS 4
Memory allocation error\&.
.RE
.PP
The
\fBaligned_alloc\fR\fB\fR
function returns a pointer to the allocated memory if successful; otherwise a
\fBNULL\fR
pointer is returned and
\fIerrno\fR
is set\&. The
\fBaligned_alloc\fR\fB\fR
function will fail if:
.PP
EINVAL
.RS 4
The
\fIalignment\fR
parameter is not a power of 2\&.
.RE
.PP
ENOMEM
.RS 4
Memory allocation error\&.
.RE
.PP
The
\fBrealloc\fR\fB\fR
function returns a pointer, possibly identical to
\fIptr\fR, to the allocated memory if successful; otherwise a
\fBNULL\fR
pointer is returned, and
\fIerrno\fR
is set to
ENOMEM
if the error was the result of an allocation failure\&. The
\fBrealloc\fR\fB\fR
function always leaves the original buffer intact when an error occurs\&.
.PP
The
\fBfree\fR\fB\fR
function returns no value\&.
.SS "Non\-standard API"
.PP
The
\fBmalloc_usable_size\fR\fB\fR
function returns the usable size of the allocation pointed to by
\fIptr\fR\&.
.PP
The
\fBmallctl\fR\fB\fR,
\fBmallctlnametomib\fR\fB\fR, and
\fBmallctlbymib\fR\fB\fR
functions return 0 on success; otherwise they return an error value\&. The functions will fail if:
.PP
EINVAL
.RS 4
\fInewp\fR
is not
\fBNULL\fR, and
\fInewlen\fR
is too large or too small\&. Alternatively,
\fI*oldlenp\fR
is too large or too small; in this case as much data as possible are read despite the error\&.
.RE
.PP
ENOMEM
.RS 4
\fI*oldlenp\fR
is too short to hold the requested value\&.
.RE
.PP
ENOENT
.RS 4
\fIname\fR
or
\fImib\fR
specifies an unknown/invalid value\&.
.RE
.PP
EPERM
.RS 4
Attempt to read or write void value, or attempt to write read\-only value\&.
.RE
.PP
EAGAIN
.RS 4
A memory allocation failure occurred\&.
.RE
.PP
EFAULT
.RS 4
An interface with side effects failed in some way not directly related to
\fBmallctl*\fR\fB\fR
read/write processing\&.
.RE
.SS "Experimental API"
.PP
The
\fBallocm\fR\fB\fR,
\fBrallocm\fR\fB\fR,
\fBsallocm\fR\fB\fR,
\fBdallocm\fR\fB\fR, and
\fBnallocm\fR\fB\fR
functions return
\fBALLOCM_SUCCESS\fR
on success; otherwise they return an error value\&. The
\fBallocm\fR\fB\fR,
\fBrallocm\fR\fB\fR, and
\fBnallocm\fR\fB\fR
functions will fail if:
.PP
ALLOCM_ERR_OOM
.RS 4
Out of memory\&. Insufficient contiguous memory was available to service the allocation request\&. The
\fBallocm\fR\fB\fR
function additionally sets
\fI*ptr\fR
to
\fBNULL\fR, whereas the
\fBrallocm\fR\fB\fR
function leaves
\fB*ptr\fR
unmodified\&.
.RE
The
\fBrallocm\fR\fB\fR
function will also fail if:
.PP
ALLOCM_ERR_NOT_MOVED
.RS 4
\fBALLOCM_NO_MOVE\fR
was specified, but the reallocation request could not be serviced without moving the object\&.
.RE
.SH "ENVIRONMENT"
.PP
The following environment variable affects the execution of the allocation functions:
.PP
\fBMALLOC_CONF\fR
.RS 4
If the environment variable
\fBMALLOC_CONF\fR
is set, the characters it contains will be interpreted as options\&.
.RE
.SH "EXAMPLES"
.PP
To dump core whenever a problem occurs:
.sp
.if n \{\
.RS 4
.\}
.nf
ln \-s \*(Aqabort:true\*(Aq /etc/malloc\&.conf
.fi
.if n \{\
.RE
.\}
.PP
To specify in the source a chunk size that is 16 MiB:
.sp
.if n \{\
.RS 4
.\}
.nf
malloc_conf = "lg_chunk:24";
.fi
.if n \{\
.RE
.\}
.SH "SEE ALSO"
.PP
\fBmadvise\fR(2),
\fBmmap\fR(2),
\fBsbrk\fR(2),
\fButrace\fR(2),
\fBalloca\fR(3),
\fBatexit\fR(3),
\fBgetpagesize\fR(3)
.SH "STANDARDS"
.PP
The
\fBmalloc\fR\fB\fR,
\fBcalloc\fR\fB\fR,
\fBrealloc\fR\fB\fR, and
\fBfree\fR\fB\fR
functions conform to ISO/IEC 9899:1990 (\(lqISO C90\(rq)\&.
.PP
The
\fBposix_memalign\fR\fB\fR
function conforms to IEEE Std 1003\&.1\-2001 (\(lqPOSIX\&.1\(rq)\&.
.SH "AUTHOR"
.PP
\fBJason Evans\fR
.RS 4
.RE
.SH "NOTES"
.IP " 1." 4
jemalloc website
.RS 4
\%http://www.canonware.com/jemalloc/
.RE
.IP " 2." 4
Valgrind
.RS 4
\%http://valgrind.org/
.RE
.IP " 3." 4
gperftools package
.RS 4
\%http://code.google.com/p/gperftools/
.RE
